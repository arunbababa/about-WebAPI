# この章の全体像

- 認証認可の基礎知識
  - 3つの方式について大枠を知っておく
    - API方式
    - JWT方式
    - セッション方式
- 参考資料
  - [認証・認可の基本（Zenn）](https://zenn.dev/isawa/articles/2b84d7d6b2f207)

---

## 深掘り用セクション

## 認証（Authentication）と認可（Authorization）の基礎

- 認証
  - 特定された誰かが本人かどうかを確認する行為
  - 例えばIDだけだと、そのクライアントのユーザ名やメアドなどから「大体あの人だろうな」は推測できる
    - でもそれが別の人に盗まれて使われている可能性はぬぐえない
    - なので例えば二段階認証などで「本当にあの人だよね？」を確認する（＝特定された誰かが本人であることを確認する行為）
    - これが認証。単に1つ一致したから「じゃぁあの人だなぁ」で終わらない
- 認可
  - 「その人（またはクライアント）が **何をしてよいか**」を決める行為（例: 管理者だけが削除できる、本人だけが参照できる、など）
  - 認証が通っていても、認可が通らなければ操作は許可されない

---

## 方式1: API方式（APIキー等）

- APIキーをリクエストパラメータに含める、またはヘッダーに入れてサーバに送信し、サーバ側で「正しいキーか」を確認して処理する方式
  - 例: `X-API-Key: <key>` のようなカスタムヘッダーで渡す（クエリに載せるよりログ等に残りにくい）
- 基本的にキーは「クライアントを識別するための秘密情報」で、固定（長期間同じ値）になりがち
- 誰でも使い回せてしまうリスクがある（漏洩したら第三者がそのまま利用できる）
- 盗まれないようにするには？（草稿）
  - **送信経路の保護**: HTTPS（TLS）必須
  - **保管の保護**: クライアント側で安全な保管（ハードコードしない・漏洩しやすい場所に置かない）
  - **キーのローテーション**: 定期更新、漏洩時の即時失効
  - **権限の最小化**: APIキーごとに権限スコープを絞る（認証と認可を分離して考える）
  - **利用制限**: レート制限、IP制限、監査ログ

---

## 方式2: JWT方式

- JSON Web Token の略
- 以下のような形式のデータ（文字列）です
  - `Base64Url(ヘッダー).Base64Url(ペイロード).Base64Url(署名)`
- Base64 / Base64Urlは、バイナリデータ等をテキストで表すためのエンコード方式
  - [Base64とは（andspace）](https://andspace.net/blog/binary)
- メモ（誤解しやすい点）
  - **JWTは暗号化ではない**（ペイロードは基本的にデコードすれば読める）。改ざん検知は「署名」で行う
  - 「クライアントからセマンティックなデータが送られるのでDBに問い合わせ不要」と言い切るのは注意
    - 署名検証だけで「本人確認（認証）」を成立させる設計は可能だが、権限確認（認可）や強制失効、最新状態の参照などでDB/キャッシュ問い合わせが必要になるケースは普通にある

---

## 方式3: セッション方式

- 流れ
  - サーバ側
    - サーバ側でセッションIDを生成する（初回リクエスト / ログイン時など）
    - `Set-Cookie` ヘッダーでセッションIDをクライアントに返す
      - ※ `HttpOnly`、`Secure`、`SameSite`、`Domain` などのCookie属性によるセキュリティ設定
    - そしてどこかのDBに「セッションID → セッション情報」を保存する（例: RedisなどのKVストア）
      - 例（イメージ）:

        ```json
        {
          "key": "session:hogehoge",
          "value": {
            "user_id": "user123",
            "created_at": 11000000,
            "expires_at": 1200000000
          }
        }
        ```

  - クライアント側
    - サーバ側から送られたセッションIDを cookie 領域に保持する（`Set-Cookie` で送られてくる）
      - 補足: cookieは「ブラウザが管理する保存領域」に保持され、以後のリクエストで自動送信される。内部実装としてSQLite等が使われることはあるが、概念的には「ブラウザが管理するキー・バリュー」と捉えるのが分かりやすい

## JWTとセッションの比較

- 前提として知ってほしい状況
  - 多くのリクエストが想定されるAPIがあるサーバは1台では対応しきれないので複数用意し、ロードバランサなどで分散させる状況がある
  - この例を題材に以下を見ていく
    - リクエストが飛ぶサーバが複数あるとどうなるか？
      - JWTの場合
        - 各リクエストにトークン（認証情報）が含まれるため、どのサーバにリクエストが飛んでも（同じ検証鍵を持つ/参照できるなら）認証を成立させやすい
        - ただし認可・強制失効・ユーザ状態の反映などで、別途DB/キャッシュ参照が必要になる設計も多い
      - セッション方式の場合
        - 各リクエストのセッションIDは全くセマンティックではない（ユーザ情報が含まれているかどうか、という意味で）
        - あくまでリクエストに含めたIDをKeyとして、サーバ側ストア（例: Redis）に問い合わせて「存在すれば認証OK」という形になりがち
        - そのため、**セッションストアへの問い合わせ**が発生する（＝共有ストアが必要）
          - スケール時に「セッション共有（中央ストア）」が必要で面倒になりやすい（※ sticky sessionで回避する設計もあるが、構成に制約が出る）
        - 反面、サーバ側でログアウト処理や強制失効ができる部分もあって、そこはクライアント依存ではないので良い
