# この章の全体像

* Expiresヘッダー
* Cache-Controlヘッダー
  * max-age
  * no-store
  * must-revalidate
  * stale-while-revalidate
  * no-cache
  * 範囲
    * private
    * public
    * s-maxage
* 中間キャッシュ
* ポイントは概念を理解し、名前から何をしてくれるのか**想起できている状態**になっていること

---

# 深掘り用セクション

## Expiresヘッダー
* こんな感じ
  * `Expires: Fri, 03 Jan 2025 00:00:00 GMT`
  * これでクライアント側に対してキャッシュをいつまで使えるかの有効期限を指定する
  * これでクライアント側はこのキャッシュを指定された有効期限まで参照できる
  * ただこのヘッダーに対応するかどうかはクライアント依存（環境による）
  * 遠すぎる未来を指定してもクライアントが可哀そう
    * データが更新されても古いデータを参照させてしまうので
    * 長くても1年ほど
      * プロジェクトによるが感覚値として持っておこう

## Cache-Controlヘッダー
* こんな感じ
  * `Cache-Control: max-age=3600`（秒数指定）
  * `Date: Fri, 03 Jan 2025 00:00:00 GMT`
  * 上の２行で、Dateに指定された日付を起点にどれぐらいの秒数キャッシュ参照していいかの有効期限指定をする
  * もっかい、つまり、Dateの日時 + max-age までクライアントはキャッシュできる（max-ageは秒単位）
  * ※ Expiresも同時に指定されている場合は、**Cache-Controlの方が新しい仕様で優先**される
  * Expiresとの違いは、Cache-Controlの方がより多くの設定ができるということ
    * 個人的にはExpiresの役割含め、こっちでいいかも？ケースバイケース
  * Cache-Controlのさらなる設定は以降へ続く

### max-age(cache-control)

### no-store(cache-control)
* キャッシュそのものを禁止する
  * すぐにデータが変化するリアルタイム性の高いアプリケーションでは必要だと感じた

### must-revalidate(cache-control)
* キャッシュが有効期限切れの場合にサーバに再検証を要求するようにする設定
  * キャッシュが切れていて、かつサーバがダウンしていてリクエスト送れないときにクライアントは有効期限が切れたキャッシュを仕方ないから参照しに行くときがある（曰く）
  * でも例えばキャッシュしているデータが株式情報とかのリアルタイム性が大事な場合は、ちゃんと再検証させてサーバにリクエストを投げさせて、エラーを返すようにしたい、そしてとにかく有効期限の切れたキャッシュを参照させたくない（古い株式情報参照させて取引ミスったとなったら信用問題）
  * そういう時に必ず再検証させてキャッシュ参照させないために、must-revalidateが生きる
    * つまり、期限切れのキャッシュの使いまわしを防げる

### stale-while-revalidate(cache-control)
* must-revalidateと関係あるので一緒に読んでね
* これはキャッシュが有効期限切れの際に再検証リクエストをサーバに要求するが、その間にキャッシュを利用できる秒数を指定できる
* さすがにリアルタイム性が重視されるアプリケーションだとあるのかな？
* でもとりま再検証しつつ、クライアントに何かしらのキャッシュデータを見せたいときに使えうる
  * 例えばあまり商品更新などがない商品ページのサイトとかね、各サービス内でも更新がそんなにないけど古いっぱなしは良くない的なAPIで使える
* まぁ前提としてmax-ageやExpiresで設定した期限を越していることが発動条件だね
* ちなみにこれが切れたら普通にサーバに再検証リクエストを送るようになり、キャッシュ参照は消える（当然）

### no-cache(cache-control)
* キャッシュされるが、使用前に必ずサーバで再検証（ETagやLast-Modified）を行う
* なのでそういった意味で絶対にキャッシュを利用しないno-storeとは全然違う
* ETagなどを付けて一回リクエストを送り、サーバはETagを保持。リソースが変更されていない場合は例えば 304 Not Modified を返して、クライアントにキャッシュ利用を促す
* 通信頻度が高く、データ量もそこそこあるようなところで力を発揮する、少しでもデータ通信料を減らしてパフォーマンス向上できる
* ETagを生成するロジックがサーバ側に必要なので若干複雑になる

### 範囲について（中間キャッシュの考え方）
* クライアントとサーバ（最終的にエンドポイント指定されたアプリケーションコードがあるところ）の間に
  * フォワードプロキシ
  * CDN
  * リバースプロキシ
  * 等
  * がある際にどこでどうキャッシュできるかを統制する考え方
    * が中間キャッシュのこと、以降詳しく見ていく

#### private
* レスポンスをクライアント専用にして、中間キャッシュ層で保存不可にする

#### public
* レスポンスを全てのキャッシュ層で保存可能にする

#### public/privateの使い分け
* 公開情報かどうか？という指標
* 公開情報なら誰かがとったものをキャッシュすることがベター、みんなにとって便利
* 非公開情報ならOUT（個人データとか他の人が見れちゃうので）
  * 例えば中間キャッシュ層に認証ロジックを組めば良いのではないか？
    * 面倒すぎる！！

#### s-maxage
* シェアードの意味のs
* つまりは公開情報、publicが設定された中間キャッシュ層向けのmax-age!!

## Cache-Control設定まとめ（簡易表）

| 設定 | ざっくり何をする？ |
| --- | --- |
| `max-age=<秒数>` | キャッシュの有効期限を**秒単位**で指定する |
| `no-store` | キャッシュ**そのものを禁止**する |
| `no-cache` | キャッシュはするが、使用前に必ずサーバで**再検証**（例：ETag / Last-Modified）する |
| `must-revalidate` | キャッシュが期限切れのとき、必ずサーバに**再検証を要求**する |
| `stale-while-revalidate=<秒数>` | 期限切れでも、再検証中は**古いキャッシュを返して良い秒数**を指定する |
| `public` | レスポンスを共有キャッシュ（プロキシ/CDN等）にも**保存可能**にする |
| `private` | レスポンスをクライアント専用にし、共有キャッシュ（プロキシ/CDN等）に**保存させない** |
| `s-maxage=<秒数>` | 共有キャッシュ向けの `max-age`（プロキシ/CDN向け） |